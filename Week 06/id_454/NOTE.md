## 字典树
> 即 Trie 树，又称单词查找树或键树，是一种树形结构。
空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

- 节点本身不存储完整单词， 
- 从根结点到某一节点，路径上的字符连起来就是该节点对应的字符串
- 每个节点的所有子节点路径都代表不同的字符
 ### 应用：
 - 用于统计和排序大量的字符串，
 - 用于搜索引擎系统用于文本词频统计。

 ### 操作
 - 查找
 - 插入
 - 删除

 ### 实现方案
- 从根结点开始一次搜索；
- 取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；
- 在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。
- 迭代过程……
- 在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找

## 并查集
> 并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。  

### 应用
- 组团
- 配对问题

### 操作
- makeSet(s):
建立一个新的并查集，其中包含s个元素集合。

- unionSet(x, y):
合并x和y所在集合，要求x和y所在集合不相交，如果相交则不合并。

- find(x):
找到x所在的集合的代表，该操作也可以用于判断两个元素是否在同一个集合。

### 实现方案
- DFS
- BFS
- 并查集


### Java模板

```java
class UnionFind { 
	private int count = 0; 
	private int[] parent; 
	public UnionFind(int n) { 
		count = n; 
		parent = new int[n]; 
		for (int i = 0; i < n; i++) { 
			parent[i] = i;
		}
	} 
	public int find(int p) { 
		while (p != parent[p]) { 
			parent[p] = parent[parent[p]]; 
			p = parent[p]; 
		}
		return p; 
	}
	public void union(int p, int q) { 
		int rootP = find(p); 
		int rootQ = find(q); 
		if (rootP == rootQ) return; 
		parent[rootP] = rootQ; 
		count--;
	}
}

```


### Python模板

```Python
def init(p): 
	# for i = 0 .. n: p[i] = i; 
	p = [i for i in range(n)] 
 
def union(self, p, i, j): 
	p1 = self.parent(p, i) 
	p2 = self.parent(p, j) 
	p[p1] = p2 
 
def parent(self, p, i): 
	root = i 
	while p[root] != root: 
		root = p[root] 
	while p[i] != i: # 路径压缩 ?
		x = i; i = p[i]; p[x] = root 
	return root
```
## 高级搜索
时间原因没有怎么学进去，后面总结

## AVL树和红黑树

### AVL树
>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1（即[-1,0,1]），和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过1)。不管我们是执行插入还是删除操作,只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。


### 红黑树
> 一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出,相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说,它的旋转次数变少，所以对于搜索,插入,删除操作多的情况下，就用红黑树。

- 每个节点非红即黑；
- 根节点是黑的；
- 每个叶节点(叶节点即树尾端NUL指针或NULL节点)都是黑的；
- 如果一个节点是红的,那么它的两儿子都是黑的；
- 对于任意节点而言,其到叶子点树NIL指针的每条路径都包含相同数目的黑节点。



### AVL树与红黑树比较
> AVL树比红黑树的维护成本较高，因为要保证一定是完全平衡条件，所以通过频繁的旋转来保持平衡；红黑树是弱平衡二叉树，相对AVL树来说，旋转的次数较少。因此决定了他们不同的应用场景。