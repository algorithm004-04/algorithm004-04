# NOTE

## 解题思路

1. 升高维度
2. 空间换时间

## 数组、链表、跳表

> 跳表

多个链表储存索引，加快访问速度

> 两数之和

```
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

链接：https://leetcode-cn.com/problems/two-sum
```


解法1： 双循环遍历，寻找两个相同的值
解法2： 先把数组的值循环放入HashMap中，再循环判断是否在map中存在与数组遍历的值相加等于target的值。 通过空间换时间，加速了循环速度


## 栈、队列、优先队列、双端队列

> TODO

## 哈希表、映射、集合

> 异位词

异位词：字符串字母顺序不一样

1. 考虑边界,字符串长度0。
2. 思路：如果是一样的字符串，排序后，字符编码一样
3. 方法一：排序
4. 方法二：统计所有的字母数量是否一致

## 泛型递归、树的递归

> 树与链表的区别

1. 树可以看做链表
2. 结点的度：一个结点含有的子结点的个数称为该结点的度；
3. 叶结点或终端结点：度为0的结点称为叶结点；
4. 树的度：一棵树中，最大的结点的度称为树的度
5. 空集合也是树，称为空树。空树中没有结点

因为重复性，多数都是用递归的方法

> 树的前序: 根节点-> 左子树-> 右子树

> 树的中序: 左子树-> 根节点-> 右子树

> 树的后序: 左子树-> 右子树-> 根节点

> 二叉搜索树

1. 空树或者
2. 左子树子节点的所有值小于它的根节点的值，右子树子节点的所有值大于它的根节点的值
3. 时间复杂度 查询操作都是logn

## 分治、回溯

> TODO
