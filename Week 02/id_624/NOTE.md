# NOTE

## 递归思维的要点：
1. 抵制人肉递归
2. 找到最近重复性
3. 数学归纳法思维

### 递归函数模版

```
def recursion(level, param, ...):
    # recursion terminator
    if level > MAX_LEVEL:
        process_result
        retrun
    
    # process logic in current level

    # drill down
    self.recursion(level + 1, param, ...)

    # reverse the current level status if needed
```

## 分治
将问题拆分为子问题，简化问题，最后将解决好的子问题合并。

## 回溯
递归的一种，相较于普通递归，主要是在递归调用后需要清理全局变量，供递归调用不满足结果返回上层后继续执行。

## 解题心得
### 求众数
- 排序法：由于众数超过全部元素的一半，所以将数组排序后取中间值即可
- 分治法：将数组拆分，单个元素的数组的众数就是数组唯一的那个元素，若两个数组的元素一样，则合并后的数组众数可以是两者任一的众数；若两个数组不同，则需要计算二者众数的数量，谁大谁就是合并后的数组的众数。这样就覆盖了所有合并时的情况。
- 随机法：由于众数占有全部元素的一半以上，理论上两次随机访问就可以找到众数，因此随机访问一个元素并计算其在数组中出现的次数来找到答案。

### n皇后问题
总体思路是：对每一行进行递归调用。遍历每一列，如果该行列满足条件就放入皇后（记录位置），如果已经到达最后一行则说明找到一个解，将解记录，回退一步（清除上一个填入的皇后），继续找能放入的位置，如果遍历到一行末尾仍然没有可以放入的位置，则清除上一个填入的皇后回退一步。

### 二叉树的最近公共祖先
对于以root为根的树，找p和q的最近公共祖先，就可以分解为，找root左儿子为根的p、q公共祖先以及root右儿子为根的p、q公共祖先，如果左儿子是二者的公共祖先，右儿子也是公共祖先，则root就是最近公共祖先（因为这种情况下，左儿子和右儿子必然分别是p和q）；否则，q和p必然是在root的左子树或右子树中，那么递归调用即可。当root为none或p或q则调用到了p或q或其他叶子，返回即可。

### 电话号码的字母组合
该题目是括号组合的泛化问题。思路就是：对于第一个数字对应的每个字母，只要与剩下数字对应字母的所有组合分别组合，就可以完成所有可能的组合了。

### 子集
- 迭代法：迭代法，结果数组中首先放入空数组，然后将待选数组中的每个元素与结果数组中已存在的元素依次组成新的元素添加进结果数组。
- 回溯法（递归）,对于待选数组中的每个元素，在三元素组合中，都可以有选中和不选两种可能

###  二叉树的最大深度和最小深度
- 最大深度：左子树的和右子树的最大深度+1
- 最小深度：由于需要过滤空子树，因此没有最大深度简单。当左子树为空时，计算右子树的最小深度；当右子树为空时计算左子树的最小深度；否则取左子树和右子树深度的较小值+1

### 后序遍历
除了递归外，还可以使用栈迭代法。逆序输出右节点优先的先序遍历即可