# NOTE
关于reverse state:
首先，这个是在递归之后，分支和回溯这两部分出现的
我们首先看递归，递归的模板中一开始并没有，为啥呢?因为我们该接触递归时，要通过简单的例子来学习或者
说就只有一个子问题。
例如我们以兔子数列或者爬楼梯为例子，子问题只有一个，且答案的求解只需要最终的结果，而不是组合，兔子
数列使用傻递归的时候，是没有使用缓存进行存储的，也能求出结果因为它结果不是求组合。

好，先跳过这里，来看为什么有分支或回溯，随着问题的复杂性的增加，那么在递归的过程中就有分支的概念，
每个问题分而治之，同时还是要看此时的求值是要什么，一般是求一个结果值，所以可以不用缓存进行保存数据
，直接求出最后的结果即可（或者说缓存只使用一唯数组）

然后随着问题的深入，答案不只是一个结果值了，而是结果的组合，为了输出组合，你必须保存每一种正确的结果
，同时，回溯也是递归的一种，在遍历子问题的过程中，需要不断的保存结果值，但是在最后证实了某一level的结果
不是正确的，此前又保存了一部分结果值，那么就需要在该level逻辑操作后，把此前保存的数据清理

回溯也是递归的一种，在遍历子问题的过程中，需要不断的保存结果值，但是如果在最后证实了某一level的结果是
不正确的，此前又已经存了一部分的结果值，那么就要在该level逻辑操作后，把此前保存的数据清理

清理对应的是数据后续的判断，所以这个清理是必不可少的，作为一个判断条件；

递归这种编程技巧的背后，其实就是树和堆栈其实就是这两种看似关联不大的数据结构。为什么这么说呢?
堆栈和树在某种层面上，其实有着强烈的对应关系，在实现一个递归函数的时候，其实就是在确定这颗树
的整体形态：什么时候终止，什么条件下生子树，也就是说我实际上是在编程实现一颗树。

那递归和堆栈又有什么关系呢? 递归树中从根节点到树中的任意节点的路径，都对应着某个时刻的函数调用
链组成的堆栈。递归越深的节点越靠近栈顶，也越早返回。因而我们可以说递归的背后是一颗树，递归的执行
过程就是在这颗树上做深度遍历的过程，每进入下一层递就是压栈，每次退出当前层归就是出栈。所有的入
栈、出栈的脉络就组成了递归树的形态。递归树是静态的逻辑背景，而当前活跃的堆栈是动态的运行背景。
(递归可以通过树、BFS+栈很好的转换为人更容易理解的样子)

递归的思想就是，将大问题分解为小问题来求解，然后在将小问题分解为小小问题求解。这样一层一层地分解
直到问题的数据规模被分解的足够小，不用递归继续分解为止；如果我们把这个一层一层分解的过程画成图，
它其实就是一颗树。我们给这个颗树起一个名字，叫做递归树。


  

