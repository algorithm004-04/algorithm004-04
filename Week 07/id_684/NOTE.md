-------位运算--------
1、移位操作：
    二进制左移动一位就是将数字翻倍，二进制右移一位，就是将数字除以2并求整数商。 
十进制 6 转换成二进制是 0000 0110 
向右移动一位是 6>>1 = 0000 0011 转换成十进制是 3
向左移动一位是 6<<1 = 0000 1100 转换成十进制是 12


//golang 代码
import "fmt"
func main(){
    fmt.Println(6>>1) // 3
    fmt.Println(6<<1) // 12
}
​
一、实战位运算要点(位运算性能好)
1、判断奇偶
x%2==1 --> (x&1)==1
x%2==0 --> (x&1)==0
2、除以2
x>>1 --> x/2
即 x=x/2 --> x=x>>1
mid=(left+right)/2 --> mid=(left+right)>>1
3、x=x&(x-1)清零最低位的1
4、x&-x=>得到最低位的1
5、x&~x=>0
二、逻辑操作：“或”：参与操作的位中只要有一个是1，最终结果就是1。
   
求 6 | 2 的结果，将 6 和 2 分别转换成二进制
6 ： 0000 0110
        |
2 ： 0000 0010
6 ： 0000 0110
//golang 代码
import "fmt"
func main(){
    fmt.Println(6|2) //6
}
三、“与”：参与操作的位中必须全是1，最终结果才是1，否则就为0。
 
求 6&2 的结果，将 6 和 2 分别转换成二进制
6 ： 0000 0110
        &
2 ： 0000 0010
2 ： 0000 0010
//golang 代码
import "fmt"
func main(){
    fmt.Println(6&2) //2
}
四、"反" ～


3: 0011
    ~
12:1100
​
五、“异或”：参与操作的位相同为0，不同为1，最终结果就位0，否则位1.
求 6^2 的结果，将 6 和 2 分别转换成二进制
6 ： 0000 0110
        ^
2 ： 0000 0010
4 ： 0000 0100
//golang 代码
import "fmt"
func main(){
    fmt.Println(6^2) //4
}
异或操作的一些特点
x^0 = x
x^1s= ~x //注意1s = ~0 (全部是1)
x^(~x)= 1s
x^x =0
c=a^b => a^c=b,b^c=a //两个数交换
a^b^c=a^(b^c)=(a^b)^c //associative

六、源码、补码和反码
1、对应有符号的数而言，二进制的最高位是符号位：0标示正数，1表示负数
以32位为例子 
 1 二进制表示 00000000 00000000 00000000 00000001
-1 二进制标示 10000000 00000000 00000000 00000001
2、正数的源码、反码、补码都是一样的。
6 转换成二进制：
源码： 00000000 00000000 00000000 00000110
反码： 00000000 00000000 00000000 00000110
补码： 00000000 00000000 00000000 00000110
3、负数的反码，它的源码符号位不变，其他位取反，补码=反码+1
-6 转换成二进制
源码： 10000000 00000000 00000000 00000110
反码： 11111111 11111111 11111111 11111001
补码： 11111111 11111111 11111111 11111010
4、计算机在运算的时候都是以补码的方式运算的。计算机计算加减乘除，都是转换为加法和位移运算完成的
    
例子 6-3 计算级反码运算 
6-3 = 6 + (-3) 
= 00000000 00000000 00000000 00000110(源码) + 10000000 00000000 00000000 00000011(源码)
= 00000000 00000000 00000000 00000110(反码) + 11111111 11111111 11111111 11111100(反码)
= 00000000 00000000 00000000 00000110(补码) + 11111111 11111111 11111111 11111101(补码)
= 00000000 00000000 00000000 00000011(补码)
= 00000000 00000000 00000000 00000011(反码) //正数的源码、反码、补码都是一样的。
= 00000000 00000000 00000000 00000011(源码) //正数的源码、反码、补码都是一样的。
= 3
七、二进制的四则运算。
二进制数的算术运算包括：加、减、乘、除四则运算。
1、加法：根据“逢二进一”规则。
0+0=0
1+0=0+1=1
1+1=0（进位1）
1+1+1=1（进位1）
例子：
6 + 3 = 9
转换成二进制运算：
  0000 0110
+ 0000 0011
------------
  0000 1001  转换成十进制为9
​
2、二进制数减法，根据“借一有二”的规则。
0-0=0
1-1=0
1-0=0
0-1=1（借位一位）
例子 8-2=6
转换成二进制
  0000 1000
- 0000 0010
------------
  0000 0110
3、二进制乘法，由低位到高位，用乘数的每一位去乘被乘数，若乘数的某一位为1，则该次部分积为被乘数；若乘数的某一位为0，则该次部分积为0。
某次部分积的最低位必须和本位乘数对齐，所有部分积相加的结果则为相乘得到的乘积。
1*1=1
1*0=0*1=0
0*0=0
例子 6*6=36
转换成二进制
   0000 0110 
 * 0000 0110
 -----------
   0000 0000
  0000 0110
 0000 0110
0000 0000
--------------
    0010 0100 转换成二进制36
    
4、二进制除法，二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，
若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。
再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。


----布隆过滤器------
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，
可以用来告诉你 “某样东西一定不存在或者可能存在”。
只要记住一句话，如果不存在一定不存在，如果存在，可能存在

-------排序----------  
﻿一、几种经典排序算法及其时间复杂度级别
冒泡、插入、选择O(n^2)基于比较
快排、归并O(nlogn)基于比较
基数、计数、桶O(n)不基于比较
二、如何分析一个排序算法？
1、学习排序算法的思路？明确原理，掌握实现以及分析性能。
2、如何分析排序算法性能？从执行效率、内存消耗以及稳定性三个方面分析排序算法性能。
3、执行效率：从以下三个方面来衡量
1）最好情况、最坏情况、平均情况时间复杂度
2）时间复杂度的系数、常数、低阶（排序的数量比较小时考虑）
3）比较次数和交换（或移动）次数
4、内存消耗：通过空间复杂度衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法是指空间复杂度为O(1)的排序算法。
5、稳定性：如果带排序的序列中存在等值的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法是稳定的。

