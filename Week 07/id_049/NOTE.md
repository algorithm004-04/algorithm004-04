 第 16 课 | 位运算
**位运算基础**
	- & 与：两位都为1结果才为1，不然都为0
		- `x&1==1 or == 0 #判断奇偶(比x%2==1高效，除法要在寄存器做一次除法运算)`
		- `x = x & (x-1) => #打掉最低位的1`
		- `x&-x=> #得到最低位的1`
	- | 或：两位都为0结果才为0，不然都为0
	- ^ 异或：两位相同为0，相异为1
	x ^ 0 = x (0 ^ 0 = 0, 0 ^ 1 = 1)
	x ^ 1s = ~x // 1s = ~0 #～x表示x取反
	x ^ (~x) = 1s #和自己的取反来异或肯定是相反的所以1s
	x ^ x = 0 #和自己来异或肯定是相同的
	a ^ b = c => a ^ c = b => a ^ b = c #a和b异或得c，那么a和c或者b异或就得出另外一半叫做swap
	a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c #associative

**指定位置的位运算**
	- 将x最右边的n位清零 `x & (~0 << n)`
	- 获取 x的第n位值(0或者1) `(x >> n) & 1`
	- 获取 x的第n位的幂值 `x & (1 << (n - 1))`
	- 仅将第n位置为1 `x | （1 << n)`
	- 仅将第n位置为0  `x & （~(1 << n))`
	- 将x最高位至第n位(含)清零`x & ((1 << n) - 1)`
	- 将第n位至第0位(含)清零`x & (~((1 << (n + 1)) - 1))`
 	- ~ 取反：0变1，1变0
	- <<左移：各二进位全部左移若干位，高位丢弃，低位补0
	- >>右移：各二进位全部右移若干位，对无效符号数，高位补0。有符号数，各编译器处理方式不一样有的补符号位(算术右移)，有的补0(逻辑右移)

**实战位运算要点**
	1. 判断奇偶
		* X%2==1——>（X&1）==1
		* X%2==0——>（X&1）==0
	2. X>>1——>X/2，即：X=X/2——>X=X>>1，mid=（left+right）/2——>mid=（left+right）>>1
	3. X=X&（X-1）清零最低位的1
	4. X&-X——>0：得到最低位的1

第 17 课 | 布隆过滤器和LRU缓存
1. 布隆过滤器VS Hash Table
	1. 布隆过滤器是一个很长的二进制向量；
	2. Hash Table是一系列随机映射函数。
布隆过滤器可用于检索一个元素是否在一个集合中。如果通过布隆过滤器查询一个元素不存在则肯定不存在，如果存在则是可能存在。
	* 优点：空间效率和查询时间都远远超过一般的算法；
	* 缺点：有一定的误识别率和删除困难。
2. LRU Cache的实现、应用和题解
	- 两个要素：大小、替换策略；
	* Hash Table + Double LinkedList
	* O(1)的查询、修改和更新的时间复杂度

第 18 课 | 排序
1. 初级排序和高级排序的实现和特性
冒泡排序
```python
import random
def bubble_sort(data):
    for i in range(len(data) - 1): 
        indicator = False 
        for j in range(len(data) - 1 - i):
            if data[j] > data[j + 1]:
                data[j], data[j+1] = data[j+1], data[j]
                indicator = True
        if not indicator: 
            break
List = [99, 11, 33, 88, 22, 44, 55, 77, 66]
data = list(range(10))
random.shuffle(data)
print(data) 
bubble_sort(data)
print(data)
```
插入排序
```python
def insertionSort(c):
    tmp = 0
    for i in range(1, len(c)): 
        tmp = c[i] #i = 1, tmp = 1 || i = 2, tmp = 7
        while i > 0 and tmp < c[i-1]:
            c[i] = c[i-1] # c[1] = c[0] = 3 || 
            print(c[1], c[i-1])
            i = i - 1 # i = 0
            print(i)
        c[i] = tmp
        print(c[i])
    return c
```
选择排序
```python
def selection_sort1(n):
    for i in range(len(n)):
        min_idx = i
        for j in range(i+1, len(n)):
            if n[min_idx] > n[j]:
                min_idx = j
        n[i], n[min_idx] = n[min_idx], n[i]
    return n
```
2. 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序，
- 交换排序：冒泡排序、快速排序
- 插入排序：简单插入排序、希尔排序
- 选择排序：简单选择排序、堆排序
- 归并排序：二路归并排序、选择归并排序


- 初级排序o(n^2)
1. 选择排序：循环一遍每次找最小值，然后把最小值和应该放置的顺序位置进行交换，数组其他位置不用动
2. 插入排序：从前到后逐步构建有序序列：对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。这个每次调整位置会移动整个数组，所以有多少元素差不多就要移动多少次数组
3. 冒泡排序：从来就不会用到，两层嵌套循环，每次查看相邻元素，如果逆序则交换。当一层循环后最大元素就会放到最后了。

- 三个o(nlogn)的排序：
1. 快速排序Quick Sort：分治。数组取标杆pivot，将小元素放到pivot左边，大元素放右边，然后依次对右边和右边的子数组继续快排；以达到整个序列有序。
2. 归并排序：O(N*LogN)（Merge Sort）分治。 大概可以理解为快排的逆向操作
    1. 把长度为n的输入序列分成两个长度为n/2的子序列
    2. 对这两个子序列分别采用归并排序
    3. 将两个排序好的子序列合并成一个最终的排序序列
 3. 堆排序：O(N*LogN)（Heap Sort）——堆插入O(LogN)，取最大/小值O(1) 
     * 数组元素依次建立小顶堆；
    * 依次取堆顶元素，并删除。

3 . 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下限，以线性时间运行，因此也称为线性时间非比较类排序
- 计数排序：（Counting Sort）：计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存 储在额外开辟的数组空间中;然后依次把计数大于 1 的填充回原数组；
- 桶排序：桶排序 (Bucket sort)的工作的原理:假设输入数据服从均匀分布，将数据分到有 限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式 继续使用桶排序进行排)；
- 基数排序：基数排序是按照低位先排序，然后收集;再按照高位排序，然后再收集;依次类 推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按 高优先级排序。