# NOTE

## 数组、链表和跳表

### 定义
数组：一块连续的内存空间，元素在物理上是相邻的，所以可以通过下标快速查找。缺点是插入和删除的速度较慢。

链表：每个元素包含值和指向下个元素的指针。优点是插入删除的速度快，缺点是查询的速度慢。

跳表：通过添加索引的方式改善链表的查询速度就是跳表。对链表每隔一个元素创建一个索引，然后对索引每隔一个索引创建一个更上层的索引，直到只有两个索引为止。这样使得查询的时间复杂度可以由O(n)降低到O(logn)。但是这样也存在缺点，就是当插入和删除元素时需要更新索引，因此插入删除的时间复杂度也退化为O(logn)。同时由于需要存储索引，因此也需要占用更多的空间。

### 工程实例
链表：LRUCache

跳表：[Redis](https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html)

### 时间复杂度对比
|          | 数组 | 链表 | 跳表    |
| -------- | ---- | ---- | ------- |
| 随机访问 | O(1) | O(n) | O(logn) |
| 头部插入 | O(1) | O(1) | O(logn) |
| 尾部插入 | O(1) | O(1) | O(logn) |
| 平均插入 | O(n) | O(1) | O(logn) |
| 删除     | O(n) | O(1) | O(logn) |

### 跳表查询的时间复杂度推导：
假设跳表n个元素，则第1层有n/2个索引节点，第2层有n/2^2，...，第k层的节点数为：

**n/2^k**

由于最高层有2个节点，所以层数k为：

```
2 = n/2^k
n/2 = 2^k
k = log2(n/2)
  = log2(n) - log2(2)
  = log2(n) - 1
```  

## 栈、队列、优先队列和双端队列
栈：后进先出
队列：先进先出
优先队列：按优先级弹出元素的队列，可以使用堆实现
双端队列：可以从两端插入或弹出元素的队列

## 思想
升维：当当前维度难以处理问题时，可以考虑提高数据的维度，例如将数组的元素狗造成二叉树。

空间换时间：通过存储索引、缓存数据等方法来提升解决问题的速度。跳表就是运用了这种思维方式。

定位指针：使用一个指针标记待处理的元素，然后寻找需要处理的元素，使得在找到处理元素时可以迅速取得待处理元素的思路。[移动零](https://leetcode-cn.com/problems/move-zeroes/)

双指针：拥有两个指针定位数据的两端，在过程中不断向中间逼近。[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)，[三数之和](https://leetcode-cn.com/problems/3sum/)

递归：找到重复问题的终结点，逆推整个过程。[爬梯子](https://leetcode.com/problems/climbing-stairs/)

## 其他
在刷题时，看到一个同学关于递归的思想解释的很到位。递归主要考虑三个问题：
1. 终止条件
2. 单元执行内容
3. 返回值

只要考虑清除这三个内容，递归就很容易实现。
