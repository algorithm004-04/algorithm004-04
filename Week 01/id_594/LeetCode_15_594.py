def threeSum(nums):     # 双指针+排序，左右两边往中间推进的解法——（背）    nums.sort()    res = []    for k in range(len(nums)-2):        if k > 0 and nums[k] == nums[k-1]:            continue        i, j = k+1, len(nums)-1        # zero = nums[k] + nums[i] + nums[j]        # print("zero:", zero)        while i < j:            zero = nums[k] + nums[i] + nums[j]            if zero > 0:                j -= 1                # print("i:", i)                while i < j and nums[j] == nums[j+1]:                    j -= 1            elif zero < 0:                i += 1                while i < j and nums[i] == nums[i-1]:                    i += 1                # print("j:", j)            elif zero == 0:                print("zero:", zero)                res.append([nums[k], nums[i], nums[j]])                i += 1                j -= 1                while i < j and nums[i] == nums[i-1]:                    i += 1                while i < j and nums[j] == nums[j+1]:                    j -= 1    return resdef threeSum2(nums):    # 暴力求解  --> 尴尬，放在LeetCode上面跑，超时了……    res = []    nums.sort()    print(nums)    for k in range(len(nums)-2):        if k > 0 and nums[k] == nums[k-1]:            continue        for i in range(k+1, len(nums)-1):            if i-1 != k and nums[i] == nums[i-1]:                continue            for j in range(i+1, len(nums)):                if j-1 != i and nums[j] == nums[j-1]:                    continue                print("当前k，i，j：", k, i, j)                print("当前num[k], 当前num[i], 当前num[j]:", nums[k], nums[i], nums[j])                zero = nums[k] + nums[i] + nums[j]                if zero == 0:                    res.append([nums[k], nums[i], nums[j]])    return resex = [-1, 0, 1, 2, -1, -4]print(threeSum2(ex))