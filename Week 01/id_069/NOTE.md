# NOTE

### 第一题： No0026 删除排序数组中的重复项

- 第一遍：未直接想出解法，参考官方题解
    + 在官方题解中使用的是双指针法，使用两个指针i，j，i指向最后一个不重复的值，j指向i的下一个值，若j指向的数据与i指向的数据不同时，i指针增加1并将j指针的数据复制到i指针的当前位置，若j指向的数据与i指向的数据一致时，则只有j指针指向下一个位置，直到遍历完整个数组。
    + 此解法的时间复杂度：O(n)

### 第二题： No0189 旋转数组
- 第一遍：使用两层循环进行处理，第一层循环k，第二次循环移动数组内容
    + 时间复杂度： O(n^2)
    + 有超时的问题出现
- 其他人的解法：
    + 第一种：看到一个比较有趣的解法，将数组看做一个双端队列，将队尾的数据pop出去，在添加到队首`nums.insert(0, nums.pop())`
        + 时间复杂度：O(k*n)
        + `insert() 的时间复杂度为： O(n)`
    + 第二种：反转的解法没有理解清楚

### 第三题： No0021 合并两个有序链表
- 第一遍：未解出，查看官方解法
    + 递归： 两个链表的值进行判断，将判断值为小的链表next与另一链表进行下一次合并操作，直到其中一个链表为空时停止


### 第四题： No0641 设计循环双端队列
- 第一遍：未解出，参考用户答案
    + 队首可以出入队、队尾亦可以出入队
    + 数组原生实现
        + 入队出队
        + 右边入队：rear++
        + 左边入队：front--
        + 入队时判断是否队满、出队时判断是否队空 且操作后均都更新指针位置
    + 由顺序循环队列分析可知
        + 队满 (rear = (rear+1)%n) == front
        + 队空 front越界时即 front < 0 时，换到队尾去 => (front+n)%n
        + 区分队空和队尾 => 初始化数组时 增加一个单元 比如规定最大存储空间为n则初始化存储数组 new Array(n+1)
            + 如front == -1时 => front = n-1

### 第五题： No0042 接雨水
- 第一遍：未解出，参考题解
    + 使用左右两个指针，分别向中间移动，如果读取当前值大于最大读取值，则将这次值付给最大读取值，否则将此值与最大读取值相减，作为可以存储水的量，直到左右两个指针相等时，结束

